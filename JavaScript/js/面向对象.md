## 1.1.工厂模式
> 工厂模式:每次返回的都是一个对象。优点：只需要传参数，不管其如何实现的。缺点：想添加类型时，必须修改原产品模型。
~~~
 function Person(name, age) {
        var obj = new Object()
        obj.name = name
        obj.age = age
        obj.fn = function () {
            return this.name
        }
        return obj
    }

    var p = Person('jack', 20)
~~~

### 1.2.构造函数模式
~~~
var action = {
    fn: function() {
        return 1
    }
}
function Person(name, age) {
    this.name = name
    this.age = age
    this.fn = action.fn
}
var p = new Person('jack', 20)
~~~

### 1.3.原型模式
~~~
function Person(name, age) {

    this.name = name
    this.age = age

}
Person.prototype = {
    constructor: Person, //注意这里一定要手动绑定
    run: function() {
        return 1
    }
}

var p = new Person('jack', 20)
~~~
### 1.4.构造函数，构造函数的原型对象，实例化对象三者关系
~~~
function Person(name, age) {

        this.name = name
        this.age = age

    }
    Person.prototype = {
        constructor: Person, //注意这里一定要手动绑定
        run: function() {
            return 1
        }
    }

    var p = new Person('jack', 20)

    // Person 构造函数
    // Person.prototype 构造函数的原型对象
    // p 实例化对象
    p.__proto === Person.prototype //一个Person的原型{}
    p.constructor ===Person   //指向一个函数 用来检测是否属于一个类
    Person.prototype //一个Person的原型{}
~~~

### 2.1构造函数的继承(组合式继承)
~~~
function Person(name,age) {
    this.name = name
    this.age = age
}
Person.prototype.firends = [1,2,4]
function Student(name) {
    Person.call(this,name)
}
Student.prototype = Object.assign({},Person.prototype)
Student.prototype.constructor = Student;
~~~

