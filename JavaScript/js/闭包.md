## 1.闭包
> 1.1闭包: 有权访问另一个函数作用域中的变量函数，本质还是函数。闭包的特性
* 在一个函数内部定义
* 函数内部可以引用函数外部的变量。
* 参数和变量不会被回收。

* 将一个变量长期保存在内存中。(变量不销毁)
* 避免全局污染。
* 私有化成员，外部不可以访问

~~~
function Fun() {
    let x = 1;
    let Fa = function() {
        x++;
        return x;
    }
    return Fa;
}
let fn = Fun();
Fn.fa() //2
Fn.fa() //3

//私有化成员
function Fun() {
    let a = 1;
    function f1() {
        a++;
        return a;
    }
    function f2() {
        a++;
        return a;
    }
    return {f1,f2};
}
let fn = Fun();
fn.f1() //私有化成员想要获取f1() 必须先调用Fun

~~~
> 1.2闭包易错点
* 引用的变量发生变化
~~~
function Fun() {
    let arr = [];
    for(var i=0;i<10;i++){
        a[i] = function() {
            return i;
        }
    }
    return arr;
}
let Fn = Fun();
Fn[0]() //10
Fn[1]() //10
//此时return i 访问的都是Fun下的i值(10)
//解决办法 1.把var 换成let  2.闭包
function Fun() {
    let arr = [];
    for(var i=0;i<10;i++){
        a[i] = function(index) {
            let _index = index;  //b
            return function(_index) { //a
                return _index
            };
        }
    }(i)
    return arr;
}
此时a的作用域在b里面

~~~
> 1.3闭包this的指向问题
~~~
let obj = {
    x: 5,
    fn: function() {
        return function(){
            rerturn this.x;
        }
    }
}
obj.fn()() // undefined 说明this指向了window
~~~

> 1.4内存泄漏问题
~~~
function Fun() {
    let a = document.getElementById('btn');
    a.onClick = function(){
        return a.id
    } 
    a = null //手动释放

}
//这么做的话a变量会一直保存而无法释放 建议手动释放
~~~