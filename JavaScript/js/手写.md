## new 过程的实现

```
function Person(name) {
    this.name = name
}
function.prototype.getName = function() {
    return this.name
}

var FactoryFn = function() {
    var obj = new Object(),
    Constr = [].shift.call(arguments);
    obj.__proto__ = Constr.prototype; //原型指向Constr的原型
    let res = Constr.apply(obj,arguments)
    return typeof res === 'object'? res||obj
}
let p = FactoryFn(Person,'jack');
p.getName() //jack


```

## bind 实现

```
Function.prototype.myBind  = function(context) {
    var that = this;
    return function() {
        return that.apply(context,arguments)
    }
}

var context = {
    name: 'jack'
}
var fn = function(age) {
    return this.name+age
}.myBind(context)

fn(20)
```

## 借用对象实现属性继承

```
var A = function(name) {
    this.name = name;
}
var B = function() {
    A.apply(this,arguments) //更正this的指向问题
}
B.prototype.getName = function(){
    return this.name
}
let p = new B('jack')
```

## 闭包封装变量

```

var mult = (function () {
    var cache = {};
    function caculate() {
        var a = 1;
        for (var i = 0, l = arguments.length; i < l; i++) {
            a = a * arguments[i]
        }
        return a;
    }
    return function () {

        let arg = Array.prototype.join.call(arguments, ',');
        if (cache[arg]) {
            return cache[arg]
        }
        return cache[arg] = caculate.apply(null,arguments);
    }

}) ()
console.log(mult(1,2,3,4))
```

## 高阶函数柯里

```
var cost = (function() {
    var res = 0;
    return function() {
        for(var i=0;i<arguments.length;i++) {
            res+=arguments[i]
        }
        return res
    }
})()
var curry = function(fn) {
    var arg = []
    return function() {
        if(arguments.length===0) {
           return fn.apply(this,arg)
        }else{
            [].push.apply(arg,arguments)
            return arguments.callee;
        }
    }
}
var costFn = curry(cost);

costFn(100)
costFn(200)
costFn(300)
costFn()
```
